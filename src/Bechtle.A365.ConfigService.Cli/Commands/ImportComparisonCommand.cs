using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using Bechtle.A365.ConfigService.Common;
using Bechtle.A365.ConfigService.Common.DomainEvents;
using Bechtle.A365.ConfigService.Common.Serialization;
using Bechtle.A365.Utilities.Rest;
using McMaster.Extensions.CommandLineUtils;

namespace Bechtle.A365.ConfigService.Cli.Commands
{
    /// <inheritdoc />
    [Command("import", Description = "import the change-set generated by the 'compare' command")]
    public class ImportComparisonCommand : SubCommand<CompareCommand>
    {
        /// <inheritdoc />
        public ImportComparisonCommand(IConsole console) : base(console)
        {
        }

        [Option("-i|--input", Description = "location of environment-dump")]
        public string InputFile { get; set; }

        [Option("-m|--mode", Description = "which operations should be executed to match the target-environment. " +
                                           "\n\t\t- 'Add'   : add keys which are new in source. " +
                                           "\n\t\t- 'Delete': remove keys that have been deleted in source. " +
                                           "\n\t\t- 'Match' : execute both 'Add' and 'Delete' operations")]
        public ComparisonMode Mode { get; set; } = ComparisonMode.Match;

        protected override bool CheckParameters()
        {
            if (!base.CheckParameters())
                return false;

            if (string.IsNullOrWhiteSpace(InputFile))
            {
                Output.WriteError("no input given (-i|--input)");
                return false;
            }

            try
            {
                // open the file and access it somehow to check for problems
                using var file = File.OpenRead(InputFile);

                if (file.Length <= 0)
                {
                    Output.WriteError($"given file '{InputFile}' is empty");
                    return false;
                }
            }
            catch (IOException e)
            {
                Output.WriteError($"could not read input-file properly: {e.Message}");
                return false;
            }

            return true;
        }

        protected override async Task<int> OnExecute(CommandLineApplication app)
        {
            if (!CheckParameters())
                return 1;

            var (readSuccess, fileContent) = await ReadInput(InputFile);
            if (!readSuccess)
                return 1;

            var comparisons = DeserializeInput(fileContent);
            if (comparisons is null || !comparisons.Any())
                return 1;

            foreach (var comparison in comparisons)
                await ExecuteActions(comparison.Target, comparison.RequiredActions);

            return 1;
        }

        private IList<EnvironmentComparison> DeserializeInput(string json)
        {
            try
            {
                return JsonSerializer.Deserialize<List<EnvironmentComparison>>(json, new JsonSerializerOptions
                {
                    Converters =
                    {
                        new JsonIsoDateConverter(),
                        new JsonStringEnumConverter(),
                        new DoubleConverter(),
                        new FloatConverter()
                    }
                });
            }
            catch (JsonException e)
            {
                Output.WriteError($"could not deserialize json: {e.Message}");
                return new List<EnvironmentComparison>();
            }
        }

        private Task ExecuteActions(EnvironmentIdentifier identifier, IEnumerable<ConfigKeyAction> actions)
        {
            try
            {
                var changes = new List<ConfigKeyAction>();
                var deletions = new List<ConfigKeyAction>();

                foreach (var action in actions)
                    switch (action.Type)
                    {
                        case ConfigKeyActionType.Set:
                            changes.Add(action);
                            break;

                        case ConfigKeyActionType.Delete:
                            deletions.Add(action);
                            break;

                        default:
                            Output.WriteError($"invalid {nameof(ConfigKeyAction)}: {action.Type:G} / {action.Type:D}");
                            throw new ArgumentOutOfRangeException(nameof(actions), $"unsupported {nameof(ConfigKeyActionType)}: {action.Type}");
                    }

                var serializedDeletions = JsonSerializer.Serialize(deletions.Select(d => d.Key).ToList());
                var serializedChanges = JsonSerializer.Serialize(changes);

                if ((Mode & ComparisonMode.Delete) != 0 && deletions.Any())
                    return RestRequest.Make(Output)
                                      .Delete(new Uri(new Uri(ConfigServiceEndpoint), $"v1/environments/{identifier.Category}/{identifier.Name}/keys"),
                                              new StringContent(serializedDeletions,
                                                                Encoding.UTF8,
                                                                "application/json"));

                if ((Mode & ComparisonMode.Add) != 0 && changes.Any())
                    return RestRequest.Make(Output)
                                      .Put(new Uri(new Uri(ConfigServiceEndpoint), $"v1/environments/{identifier.Category}/{identifier.Name}/keys"),
                                           new StringContent(serializedChanges,
                                                             Encoding.UTF8,
                                                             "application/json"));
            }
            catch (Exception e)
            {
                Output.WriteErrorLine($"could not update '{identifier}': {e.Message}");
            }

            return Task.CompletedTask;
        }

        private async Task<(bool, string)> ReadInput(string path)
        {
            string fileContent;
            try
            {
                await using (var file = File.OpenRead(path))
                {
                    using var reader = new StreamReader(file, Encoding.UTF8, leaveOpen: true);
                    fileContent = await reader.ReadToEndAsync();
                }

                if (string.IsNullOrWhiteSpace(fileContent))
                {
                    Output.WriteError($"could not read content of '{path}'");
                    return (false, null);
                }
            }
            catch (IOException e)
            {
                Output.WriteError($"could not read input-file properly: {e.Message}");
                return (false, null);
            }

            return (true, fileContent);
        }
    }
}